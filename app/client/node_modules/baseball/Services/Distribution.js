import { helper } from 'baseball/Utility/helper';
var pitchDefinitions = helper.pitchDefinitions;

/**
 * For Probability!
 * @constructor
 */
var Distribution = function() {
};

var random = Math.random,
    min = Math.min,
    max = Math.max,
    floor = Math.floor,
    ceil = Math.ceil,
    abs = Math.abs,
    sqrt = Math.sqrt;

Distribution.prototype = {
    identifier : 'Distribution',
    constructor : Distribution,
    /**
     * @param scale {number}
     * @returns {number}
     */
    chance : function(scale) {
        if (!scale) scale = 1;
        return random() * scale;
    },
    /**
     * @param fielder {Player}
     * @returns {boolean}
     */
    error : function(fielder) {
        return (100-fielder.skill.defense.fielding)*0.40 + 4 > random()*100;
    },
    /**
     * @param power
     * @param flyAngle
     * @returns {number}
     */
    landingDistance : function(power, flyAngle) {
        return (10 + random() * 320 + power/300
                + (random() * power/75) * 150)

            * (1 - abs(flyAngle - 30)/60);
    },
    /**
     * @returns {{x: number, y: number}}
     */
    pitchLocation : function() {
        var x, y;
        if (random() < 0.5) {
            x = 50 + floor(random()*70) - floor(random()*15);
        } else {
            x = 150 + floor(random()*15) - floor(random()*70);
        }
        y = 30 + (170 - floor(sqrt(random()*28900)));
        return {x: x, y: y};
    },
    /**
     * swing centering basis
     * @returns {number}
     */
    centralizedNumber : function() {
        return 100 + floor(random()*15) - floor(random()*15);
    },
    /**
     * @param eye {Player.skill.offense.eye}
     * @param x
     * @param y
     * @param umpire {Umpire}
     */
    swingLikelihood : function(eye, x, y, umpire) {
        var swingLikelihood = (200 - abs(100 - x) - abs(100 - y))/2;
        if (x < 60 || x > 140 || y < 50 || y > 150) { // ball
            /** 138 based on avg O-Swing of 30% + 8% for fun, decreased by better eye */
            swingLikelihood = (swingLikelihood + 138 - eye)/2 - 15*umpire.count.balls;
        } else {
            /** avg Swing rate of 65% - 8% for laughs, increased by better eye */
            swingLikelihood = (57 + (2*swingLikelihood + eye)/3)/2;
        }
        // higher late in the count
        return swingLikelihood - 35 + 2*(umpire.count.balls + 8*umpire.count.strikes);
    },
    /**
     * @param target {number} 0-200
     * @param control {number} 0-100
     * @returns {number}
     */
    pitchControl : function(target, control) {
        var effect = (50 - random()*100)/(1+control/100);
        return min(199.9, max(0.1, target + effect));
    },
    /**
     * @param pitch {Game.pitchInFlight}
     * @param pitcher {Player}
     * @param x {number}
     * @param y {number}
     * @returns {object|{x: number, y: number}}
     * 0.5 to 1.5 of the pitch's nominal breaking effect X
     * 0.5 to 1.5 of the pitch's nominal breaking effect Y, magnified for lower Y
     */
    breakEffect : function(pitch, pitcher, x, y) {
        var effect = {};
        effect.x = floor(x + (pitch.breakDirection[0]
            * ((0.50 + 0.5*random() + (pitcher.pitching[pitch.name]).break/200))));
        effect.y = floor(y + (pitch.breakDirection[1]
            * ((0.50 + 0.5*random() + (pitcher.pitching[pitch.name]).break/200)/(0.5 + y/200))));
        return effect;
    },
    /**
     * Determine the swing target along an axis
     * @param target {number} 0-200
     * @param actual {number} 0-200
     * @param eye {number} 0-100
     * @returns {number} 0-200
     */
    cpuSwing : function(target, actual, eye) {
        eye = min(eye, 100); // higher eye would overcompensate here
        return 100 + (target - 100)*(0.5+random()*eye/200) - actual;
    },
    /**
     * Determine the swing scalar
     * @param eye {number} 0-100
     * @returns {number}
     */
    swing : function(eye) {
        return 100/(eye + 25 + random()*50);
    },
    /**
     * @param pitch {Object} game.pitchInFlight
     * @param catcher {Player}
     * @param thief {Player}
     * @param base {Number} 1,2,3,4
     * @returns {boolean}
     */
    stealSuccess(pitch, catcher, thief, base) {
        var rand = random(),
            rand2 = random();

        var pitchBaseSpeedMultiplier = (pitchDefinitions[pitch.name] || ['','',0.6])[2];

        return (thief.skill.offense.speed*2 + thief.skill.offense.eye*rand) - base*50 + 75
             > (pitchBaseSpeedMultiplier * pitch.velocity
               + catcher.skill.defense.catching + catcher.skill.defense.throwing * rand2);
    },
    /**
     * @param pitch {Object} game.pitchInFlight
     * @param catcher {Player}
     * @param thief {Player}
     * @param base {Number} 1,2,3,4
     * @returns {boolean}
     */
    willSteal(pitch, catcher, thief, base) {
        return random() < 0.2 && stealSuccess(pitch, catcher, thief, base);
    }
};

for (var fn in Distribution.prototype) {
    if (Distribution.prototype.hasOwnProperty(fn)) {
        Distribution[fn] = Distribution.prototype[fn];
    }
}

Distribution.main = function() {
    var ump = {
        count: {
            balls: 0,
            strikes: 0
        }
    };
    while (ump.count.balls < 4) {
        while (ump.count.strikes < 3) {
            console.log('S', ump.count.strikes, 'B', ump.count.balls);
            console.log('middle', [15, 35, 55, 75, 95].map(x => {
                return Distribution.swingLikelihood(x, 100, 100, ump)|0;
            }));
            console.log('corner', [15, 35, 55, 75, 95].map(x => {
                return Distribution.swingLikelihood(x, 50, 50, ump)|0;
            }));
            console.log('ball', [15, 35, 55, 75, 95].map(x => {
                return Distribution.swingLikelihood(x, 15, 15, ump)|0;
            }));
            ump.count.strikes++;
        }
        ump.count.balls++;
        ump.count.strikes = 0;
    }
};

export { Distribution }