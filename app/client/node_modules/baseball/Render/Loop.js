import { Ball } from './mesh/Ball';
import { Mound } from './mesh/Mound';
import { Base } from './mesh/Base';
import { Field } from './mesh/Field';
import { Grass } from './mesh/Grass';
import { BattersEye } from './mesh/BattersEye';
import { Wall } from './mesh/Wall';
import { lighting } from './scene/lighting';

var VERTICAL_CORRECTION = 0;

class Loop {
    constructor(elementClass) {
        this.elementClass = elementClass;
        this.main();
        window.loop = this;
    }
    loop() {
        requestAnimationFrame(this.loop.bind(this));
        this.objects.map(i => i.animate());
        //this.breathe();
        this.renderer.render(this.scene, this.camera);
    }
    main() {
        this.objects = [];
        if (this.getThree()) {

            var THREE = this.THREE;
            var scene = this.scene = new THREE.Scene();
            var camera = this.camera = new THREE.PerspectiveCamera(60, this.getAspect(), 0.1, 500);
            this.attach();
            this.lighting = lighting;
            lighting.addTo(scene);

            this.resetCamera();
            this.loop();

        }
    }
    addStaticMeshes() {
        new Field().join(this);
        new Mound().join(this);
        new Grass().join(this);
        new Grass(this, true);
        new BattersEye().join(this);

        new Wall(this, -30);
        new Wall(this, -15);
        new Wall(this, 15);
        new Wall(this, 30);

        new Base(this, 'first');
        new Base(this, 'second');
        new Base(this, 'third');
        new Base(this, 'home');
    }
    breathe() {
        var pos = this.camera.position;
        var x = pos.x, y = pos.y, z = pos.z;
        var rate = 0.0005 * this.bob || 1;
        if (y > 0.6) {
            this.bob = -1;
        } else if (y < -0.6) {
            this.bob = 1;
        }
        //pos.x += rate;
        pos.y += rate;
        pos.z += rate;
    }
    getThree() {
        if (this.THREE === Loop.prototype.THREE && typeof window === 'object' && window.THREE) {
            return this.THREE = window.THREE;
        }
        return false;
    }
    attach() {
        window.removeEventListener('resize', this.onResize.bind(this), false);
        window.addEventListener('resize', this.onResize.bind(this), false);
        var element = document.getElementsByClassName(this.elementClass)[0];
        element.innerHTML = '';
        var THREE = this.THREE;
        var renderer = new THREE.WebGLRenderer({ alpha: true });
        this.setSize(renderer);
        //renderer.setClearColor(0xffffff, 0);

        element.appendChild(renderer.domElement);

        this.renderer = renderer;
        return renderer;
    }
    onResize() {
        var element = document.getElementsByClassName(this.elementClass)[0];
        this.camera.aspect = this.getAspect();
        this.camera.fov = 90 - 30 * (element.offsetWidth / 1000);
        this.camera.updateProjectionMatrix();
        this.setSize(this.renderer);
    }
    setSize(renderer) {
        var element = document.getElementsByClassName(this.elementClass)[0];
        var width = element.offsetWidth;
        renderer.setSize(width, HEIGHT);
    }
    getAspect() {
        var element = document.getElementsByClassName(this.elementClass)[0];
        return element.offsetWidth / HEIGHT;
    }
    resetCamera() {
        this.moveCamera(0, VERTICAL_CORRECTION, 6);
    }
    moveCamera(x, y, z) {
        this.forAllLoops(function(loop) {
            loop.camera.position.x = x;
            loop.camera.position.y = y;
            loop.camera.position.z = z;
        });
    }
    forAllLoops(fn) {
        if (this.background) {
            fn(this.background);
        }
        if (this.foreground) {
            fn(this.foreground);
        }
        fn(this);
    }


    test(d, s, f) {
        var ball = new Ball();
        ball.deriveTrajectory({
            travelDistance: d,
            splay: s,
            flyAngle: f
        });
        ball.join(this);
    }
}

var HEIGHT = 700;
Loop.prototype.THREE = {};
Loop.prototype.constructors = {
    Ball : Ball,
    Mound: Mound,
    Field: Field
};

export { Loop };