import { AbstractMesh } from './AbstractMesh';
import { Loop } from '../Loop';
import { Mathinator } from 'baseball/Services/Mathinator';

class Ball extends AbstractMesh {
    constructor(loop, trajectory, rpm) {
        super();
        if (!(loop instanceof Loop) && loop instanceof Array) {
            trajectory = loop;
        }
        this.trajectory = trajectory ? trajectory : [];
        this.getMesh();
        if (loop instanceof Loop) {
            this.join();
        }
        this.setRotation(rpm || this.DEFAULT_RPM);
    }
    getMesh() {
        /** @see threex.sportballs */
        var baseURL	= 'public/';
        var THREE = window.THREE;
        var loader = new THREE.TextureLoader();
        var textureColor= loader.load(baseURL + 'images/SoftballColor.jpg');
        var textureBump	= loader.load(baseURL + 'images/SoftballBump.jpg');
        var geometry	= new THREE.SphereGeometry(0.5, 32, 16);
        var material	= new THREE.MeshPhongMaterial({
            map	: textureColor,
            bumpMap	: textureBump,
            bumpScale: 0.01
        });
        this.mesh = new THREE.Mesh(geometry, material);
        return this.mesh;
    }
    animate() {
        var frame = this.trajectory.pop(),
            pos = this.mesh.position;

        if (frame) {
            pos.x += frame.x;
            pos.y += frame.y;
            pos.z += frame.z;
        }
        this.rotate();

        if (!this.trajectory.length) {
            this.detach();
        }
    }
    rotate() {
        var rotation = this.rotation;
        this.mesh.rotation.x += rotation;
        this.mesh.rotation.y += rotation;
    }
    setRotation(rpm) {
        this.RPM = rpm;
        this.RPS = this.RPM / 60;
        this.RP60thOfASecond = this.RPS / 60;
        this.rotation = this.RP60thOfASecond * 360 * Math.PI / 180;
    }
    deriveTrajectory(result, pitch) {
        var dragScalarApproximation = {
            distance: 1,
            apexHeight: 0.57,
            airTime: 0.96
        };

        var flyAngle = result.flyAngle,
            distance = Math.abs(result.travelDistance),
            scalar = result.travelDistance < 0 ? -1 : 1,
            splay = result.splay; // 0 is up the middle

        flyAngle = 1 + Math.abs(flyAngle); // todo why plus 1?
        if (flyAngle > 90) flyAngle = 180 - flyAngle;

        // velocity in m/s, I think
        var velocity = dragScalarApproximation.distance * Math.sqrt(9.81 * distance / Math.sin(2*Math.PI*flyAngle/180));
        var velocityVerticalComponent = Math.sin(Mathinator.RADIAN * flyAngle) * velocity;
        // in feet
        var apexHeight = velocityVerticalComponent*velocityVerticalComponent/(2*9.81) * dragScalarApproximation.apexHeight;
        // in seconds
        var airTime = 1.5 * Math.sqrt(2*apexHeight/9.81) * dragScalarApproximation.airTime; // 2x freefall equation

        var origin = {
            x: result.x,
            y: 0,
            z: 0
        };

        var extrema = {
            x: Math.sin(splay / 180 * Math.PI) * distance,
            y: apexHeight,
            z: -Math.cos(splay / 180 * Math.PI) * distance
        };

        var frames = [],
            frameCount = airTime * 60 | 0,
            counter = frameCount,
            frame = 0;

        var lastHeight = 0;

        while (counter--) {
            var progress = (++frame)/frameCount,
                percent = progress * 100;

            // this equation is approximate
            var y = apexHeight - Math.pow(Math.abs(50 - percent)/50, 1.2) * apexHeight;

            frames.push({
                x: extrema.x/frameCount,
                y: lastHeight - y, // this is inverted compared to positive Z space
                z: extrema.z/frameCount
            });

            lastHeight = y;
        }
        this.trajectory = frames;
        return frames;
    }
}

Ball.prototype.DEFAULT_RPM = 1000;
Ball.prototype.RPM = 1000;
Ball.prototype.RPS = 1000 / 60;
Ball.prototype.RP60thOfASecond = 1000 / 60 / 60;
Ball.prototype.rotation = 1000 / 60 / 60 * 360 * Math.PI / 180; // in radians per 60th of a second

export { Ball }