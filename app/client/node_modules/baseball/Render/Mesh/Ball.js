import { AbstractMesh } from './AbstractMesh';
import { Loop } from '../Loop';
import { Mathinator } from 'baseball/Services/Mathinator';

class Ball extends AbstractMesh {
    constructor(loop, trajectory, rpm) {
        super();
        if (!(loop instanceof Loop) && loop instanceof Array) {
            trajectory = loop;
        }
        this.trajectory = trajectory ? trajectory : [];
        this.breakingTrajectory = [];
        this.getMesh();
        if (loop instanceof Loop) {
            this.join();
        }
        this.setRotation(rpm || this.DEFAULT_RPM);
    }
    getMesh() {
        /** @see threex.sportballs */
        var baseURL	= 'public/';
        var THREE = window.THREE;
        var loader = new THREE.TextureLoader();
        var textureColor= loader.load(baseURL + 'images/BaseballColor.jpg');
        var textureBump	= loader.load(baseURL + 'images/BaseballBump.jpg');
        var geometry	= new THREE.SphereGeometry(0.5, 32, 16);
        var material	= new THREE.MeshPhongMaterial({
            map	: textureColor,
            bumpMap	: textureBump,
            bumpScale: 0.01
        });
        this.mesh = new THREE.Mesh(geometry, material);
        return this.mesh;
    }
    animate() {
        var frame = this.trajectory.shift(),
            pos = this.mesh.position;

        if (frame) {
            pos.x += frame.x;
            pos.y += frame.y;
            pos.z += frame.z;
        }
        if (frame.x + frame.y + frame.z !== 0) {
            this.rotate();
        }
        if (!this.trajectory.length) {
            this.detach();
        }
    }
    rotate() {
        var rotation = this.rotation;
        this.mesh.rotation.x += rotation;
        this.mesh.rotation.y += rotation;
    }
    setRotation(rpm) {
        this.RPM = rpm;
        this.RPS = this.RPM / 60;
        this.RP60thOfASecond = this.RPS / 60;
        this.rotation = this.RP60thOfASecond * 360 * Math.PI / 180;
    }
    exportPositionTo(mesh) {
        mesh.position.x = this.mesh.position.x;
        mesh.position.y = this.mesh.position.y;
        mesh.position.z = this.mesh.position.z;
    }
    derivePitchingTrajectory(game) {
        var top = 200 - game.pitchTarget.y,
            left = game.pitchTarget.x,
            breakTop = 200 - game.pitchInFlight.y,
            breakLeft = game.pitchInFlight.x,
            flightTime = Mathinator.getFlightTime(game.pitchInFlight.velocity);

        var scale = 2.8/100;
        var origin = {
            x: (game.pitcher.throws == 'left' ? 20 : -20) * scale,
            y: (100) * scale,
            z: -60.5 // mound distance
        };
        this.mesh.position.x = origin.x;
        this.mesh.position.y = origin.y;
        this.mesh.position.z = origin.z;

        var ARC_APPROXIMATION_Y_ADDITIVE = 50;
        var terminus = {
            x: (left - 100) * scale,
            y: (100 - top + ARC_APPROXIMATION_Y_ADDITIVE) * scale,
            z: 0
        };
        var breakingTerminus = {
            x: (breakLeft - 100) * scale,
            y: (100 - breakTop - ARC_APPROXIMATION_Y_ADDITIVE) * scale,
            z: 0
        };

        var lastPosition = {
            x: origin.x, y: origin.y, z: origin.z
        },
        lastBreakingPosition = {
            x: origin.x, y: origin.y, z: origin.z
        };

        var frames = [], breakingFrames = [],
            frameCount = flightTime * 60 | 0,
            counter = frameCount | 0,
            frame = 0;

        while (counter--) {
            var progress = (++frame)/frameCount;

            var position = {
                x: origin.x + (terminus.x - origin.x) * progress,
                y: origin.y + (terminus.y - origin.y) * progress,
                z: origin.z + (terminus.z - origin.z) * progress
            };
            var breakingInfluencePosition = {
                x: origin.x + (breakingTerminus.x - origin.x) * progress,
                y: origin.y + (breakingTerminus.y - origin.y) * progress,
                z: origin.z + (breakingTerminus.z - origin.z) * progress
            };
            var momentumScalar = Math.pow(1 - progress, 0.58), // approximation of arc, meaningless constant
                breakingScalar = 1 - momentumScalar,
                scalarSum = momentumScalar + breakingScalar;
            var breakingPosition = {
                x: (position.x * momentumScalar + breakingInfluencePosition.x * breakingScalar)/scalarSum,
                y: (position.y * momentumScalar + breakingInfluencePosition.y * breakingScalar)/scalarSum,
                z: (position.z * momentumScalar + breakingInfluencePosition.z * breakingScalar)/scalarSum
            };
            var increment = {
                x: position.x - lastPosition.x,
                y: position.y - lastPosition.y,
                z: position.z - lastPosition.z
            };
            var breakingIncrement = {
                x: breakingPosition.x - lastBreakingPosition.x,
                y: breakingPosition.y - lastBreakingPosition.y,
                z: breakingPosition.z - lastBreakingPosition.z
            };

            lastPosition = position;
            lastBreakingPosition = breakingPosition;

            breakingFrames.push(breakingIncrement);
            frames.push(increment);
        }

        var pause = 60;
        while (pause--) {
            breakingFrames.push({x:0, y:0, z:0});
            frames.push({x:0, y:0, z:0});
        }

        this.breakingTrajectory = breakingFrames;
        this.trajectory = frames;
        return frames;
    }
    deriveTrajectory(result, pitch) {
        var dragScalarApproximation = {
            distance: 1,
            apexHeight: 0.57,
            airTime: 0.96
        };

        var flyAngle = result.flyAngle,
            distance = Math.abs(result.travelDistance),
            scalar = result.travelDistance < 0 ? -1 : 1,
            splay = result.splay; // 0 is up the middle

        flyAngle = 1 + Math.abs(flyAngle); // todo why plus 1?
        if (flyAngle > 90) flyAngle = 180 - flyAngle;

        // velocity in m/s, I think
        var velocity = dragScalarApproximation.distance * Math.sqrt(9.81 * distance / Math.sin(2*Math.PI*flyAngle/180));
        var velocityVerticalComponent = Math.sin(Mathinator.RADIAN * flyAngle) * velocity;
        // in feet
        var apexHeight = velocityVerticalComponent*velocityVerticalComponent/(2*9.81) * dragScalarApproximation.apexHeight;
        // in seconds
        var airTime = 1.5 * Math.sqrt(2*apexHeight/9.81) * dragScalarApproximation.airTime; // 2x freefall equation

        var scale = 2.8/100;

        var origin = {
            x: pitch.x + result.x - 100,
            y: pitch.y + result.y - 100,
            z: 0
        };

        this.mesh.position.x = origin.x * scale;
        this.mesh.position.y = origin.y * scale;
        this.mesh.position.z = origin.z;

        var extrema = {
            x: Math.sin(splay / 180 * Math.PI) * distance,
            y: apexHeight,
            z: -Math.cos(splay / 180 * Math.PI) * distance
        };

        var frames = [],
            frameCount = airTime * 60 | 0,
            counter = frameCount,
            frame = 0;

        var lastHeight = 0;

        while (counter--) {
            var progress = (++frame)/frameCount,
                percent = progress * 100;

            // this equation is approximate
            var y = apexHeight - Math.pow(Math.abs(50 - percent)/50, 1.2) * apexHeight;

            frames.push({
                x: extrema.x/frameCount,
                y: y - lastHeight,
                z: extrema.z/frameCount
            });

            lastHeight = y;
        }
        this.trajectory = frames;
        return frames;
    }
}

Ball.prototype.DEFAULT_RPM = 1000;
Ball.prototype.RPM = 1000;
Ball.prototype.RPS = 1000 / 60;
Ball.prototype.RP60thOfASecond = 1000 / 60 / 60;
Ball.prototype.rotation = 1000 / 60 / 60 * 360 * Math.PI / 180; // in radians per 60th of a second

export { Ball }