import { AbstractMesh } from './AbstractMesh';
import { Loop } from '../Loop';

class Ball extends AbstractMesh {
    constructor(loop, trajectory, rpm) {
        super();
        if (!(loop instanceof Loop) && loop instanceof Array) {
            trajectory = loop;
        }
        this.trajectory = trajectory ? trajectory : [];
        this.getMesh();
        if (loop instanceof Loop) {
            this.join();
        }
        this.setRotation(rpm || this.DEFAULT_RPM);
    }
    getMesh() {
        /** @see threex.sportballs */
        var baseURL	= 'public/';
        var THREE = window.THREE;
        var loader = new THREE.TextureLoader();
        var textureColor= loader.load(baseURL + 'images/SoftballColor.jpg');
        var textureBump	= loader.load(baseURL + 'images/SoftballBump.jpg');
        var geometry	= new THREE.SphereGeometry(0.5, 32, 16);
        var material	= new THREE.MeshPhongMaterial({
            map	: textureColor,
            bumpMap	: textureBump,
            bumpScale: 0.01
        });
        this.mesh = new THREE.Mesh(geometry, material);
        return this.mesh;
    }
    animate() {
        var frame = this.trajectory.pop(),
            pos = this.mesh.position;

        if (frame) {
            pos.x += frame.x;
            pos.y += frame.y;
            pos.z += frame.z;
        }
        this.rotate();

        if (!this.trajectory.length) {
            this.detach();
        }
    }
    rotate() {
        var rotation = this.rotation;
        this.mesh.rotation.x += rotation;
        this.mesh.rotation.y += rotation;
    }
    setRotation(rpm) {
        this.RPM = rpm;
        this.RPS = this.RPM / 60;
        this.RP60thOfASecond = this.RPS / 60;
        this.rotation = this.RP60thOfASecond * 360 * Math.PI / 180;
    }
}

Ball.prototype.DEFAULT_RPM = 1000;
Ball.prototype.RPM = 1000;
Ball.prototype.RPS = 1000 / 60;
Ball.prototype.RP60thOfASecond = 1000 / 60 / 60;
Ball.prototype.rotation = 1000 / 60 / 60 * 360 * Math.PI / 180; // in radians per 60th of a second

export { Ball }